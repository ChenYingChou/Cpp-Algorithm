/* dfsdp.cc

   http://duanple.blog.163.com/blog/static/709717672008930104124684/

   記f[i][s1]為第i-1行全滿且第i行狀態為s1時的種數，便有如下遞推關係:
     f[i][s1] = sigma(f[i-1][s2]);
   其中(s1, s2)整體作為一個放置方案， 這樣f[h+1][0]即是答案了

   對於每一個位置，我們有三种放置方法：
    1. 豎直放置
    2. 水平放置
    3. 不放置

   d為當前列號 ，初始化d, s1, s2都為0;對應以上三种放置方法，s1, s2的調整為:
    1. d = d + 1, s1 << 1 | 1, s2 << 1
    2. d = d + 2, s1 << 2 | 3, s2 << 2 | 3
    3. d = d + 1, s1 << 1    , s2 << 1 | 1

   先就第一種情況解釋一下，另外的兩種情況可以類推

   S1<<1|1即為把s1的二進製表示後面加上一個1，對就於本題來說就是(d+1)列上放置，
   s2<<1即為把s2的二進製表示後面加上一個0，對於本題來說就是(d+1)列上不放置。

   但為什麼s1、s2會如此變化呢？本人在此處想了好長時間，後來想明白了，s1對應於
   本行的狀態，s2對應於上一行的狀態，能豎直放置意味著上一行的(d+1)列是空著的，
   因此此時上一行的狀態為s2<<1，同時豎置放置了之後，則本行(d+1)行放置了東西，
   狀態於是變為s1<<1|1; 當d = w時保存狀態。

   對於初始時的f值，可以假設第0行全滿，第一行只有兩种放法:
    1. 水平放置 d = d + 2, s << 2 | 3
    2. 不放置   d = d + 1, s << 1

   另外，利用滾動數組，可以減少空間的開銷
   還有一個可以提高較率的地方，當輸入的 w > h 時，對調，因為橫向的運算是指數
   級的， 而列向的是線性的.

   ==========================================================================

   <狀態移轉範例> 3 x 8 --> 8 x 3

    R[0] 為初始化值, 僅最後一個為1, 其餘為零

            000b    001b    010b    011b    100b    101b    110b    111b
   ----------------------------------------------------------------------------
    R[0]     0       0       0       0       0       0       0       1
                                             |       |               |
                                     +------(加)----(加)------------(加)
                                     |
   ----------------------------------V-----------------------------------------
    R[1]     1       0       0       1       0       0       1       0
             ^                       ^
             |                       |
             |                       +-- R[0][100b] + R[0][101b] + R[0][111b]
             +-- R[0][111b]              因為本列狀態索引為 011b, 分析如下:
                                         1.本列(0) -> 前列 直1(1)--->(1)--->(1)
                                         2.本列(1) -> 前列 直2(0)--->(0) 橫1(1)
                                         3.本列(1) -> 前列 直2(0) 橫1(1) 橫2(1)
   ----------------------------------------------------------------------------
    R[2]     0       1       0       0       1       0       0       3
    R[3]     3       0       0       4       0       0       4       0
    R[4]     0       4       0       0       4       0       0      11
    R[5]    11       0       0      15       0       0      15       0
    R[6]     0      15       0       0      15       0       0      41
    R[7]    41       0       0      56       0       0      56       0
    R[8]     0      56       0       0      56       0       0     153
   ---------------------------------------------------------------- | ---------
                                                                    |
                                                     解答: 153 <----+

 */

#include <iostream>
#include <cstring>

#define MAX_COLS 20

using namespace std;

static int w;
static unsigned long long dp[2][1 << MAX_COLS];
static int T;   // {0,1}, T:目前處理列的狀態指標, T^1:前一列的狀態指標

static void output_state(int row, unsigned long long *p, int size)
{
    cout << "R[" << row << "]";
    while (size > 0) {
        cout << '\t' << *p++;
        size--;
    }
    cout << endl;
}

// DFS 枚舉這一列的放置狀態: 假設前一列已放满(其狀態為dp[T^1]), 由前一列狀態
// 推導出這一列狀態(dp[T])。為節省空間採用雙緩衝區 dp[2][], 以 T 表示目前列。
// 呼叫 DFS(0,0,0) 會執行 2^w 次, 相當於計算出本列採用 bits 表示的所有狀態。
static void DFS(int col, int next_stat, int prev_stat) {
    if (col >= w) {
        dp[T][next_stat] += dp[1^T][prev_stat];
        return;
    }

    col++;
    if (col <= w) { // 至少有1個位置, 可放(垂直)可不放
        DFS(col, (next_stat << 1)|0, (prev_stat << 1)|1); // 不放置
        DFS(col, (next_stat << 1)|1, (prev_stat << 1)|0); // 垂直放置
    }

    col++;
    if (col <= w) { // 有兩個位置, 水平放置
        DFS(col, (next_stat << 2)|3, (prev_stat << 2)|3); // 水平放置
    }
}

int main(int argc, char *argv[])
{
    int debug = 0;
    if (argc > 1 && strcmp(argv[1], "-d") == 0) debug = 1;

    int h;
    while (!(cin >> h >> w).eof()) {
        if (h <= 0 && w <= 0) break;

        if (h == 0 || w == 0 || (h & w & 1)) {
            cout << 0 << endl;
            continue;
        }

        if (w > h) swap(w, h);

        if (w > MAX_COLS) {
            cout << "*** width(" << w << ") must be 0~" << MAX_COLS << endl;
            continue;
        }

        int bigest = (1 << w) - 1;

        // 初始化, 視為前一行全满, 只有最後一個狀態位置為1，其他狀態位置為0
        // 即 f(0) = 1 --> dp[][0b111...1] = dp[][bigest] = 1
        memset(dp, 0, sizeof(dp[0]));
        dp[T=0][bigest] = 1;
        if (debug) output_state(0, dp[T], bigest+1);

        for (int i = 1; i <= h; i++) {
            T ^= 1;
            memset(dp[T], 0, sizeof(dp[T]));
            DFS(0, 0, 0);
            if (debug) output_state(i, dp[T], bigest+1);
        }

        cout << dp[T][bigest] << endl;
    }
    return 0;
}

